
# 2023.07.31
## 시간 복잡도와 알고리즘
### 시간 복잡도는 알고리즘의 선택기준 
### 보통 1억번의 연산 횟수를 1초의 시간으로 간주 ex) 2초의 제한 시간이라면 2억번의 연산 횟수를 말함

### 빅 오메가 -> 최선 일때
### 빅 세타 -> 보통 일때
### 빅 오 -> 최악의 경우

### 1부터 100까지의 랜덤한 수를
### 1부터 100까지 도는 for 문안에서 랜덤한 수를 만났을떄 break 한다면
### 1일때가 빅 오메가 일 것이며
### 100일때가 빅 오 이다

### 항상 빅오를 생각하고 코드를 짜는것이 중요

### 예를 들어 오름차순으로 수를 정렬하라는 문제에서
### 개수가 N (1<= N <= 1,000,000) 이라면

### 버블 정렬의 경우는 시간 복잡도가 n의 제곱
### 병합 정렬의 경우 n log n 이기 때문에 
### 병합 정렬이 시간 복잡도의 선택 기준에 따라 좀더 적합 하다고 할 수 있음

### 일반적으로 N vs 3N 앞에 상수는 무시함
### n의 제곱 같은 것과 비교가 되지않기 떄문에 상수는 무시

### 알맞은 알고리즘과 비효율적인 로직을 효율적으로 변경하는것이 핵심


# 2023.08.01

## 코드의 논리 오류 해결 디버깅

### 가장 뛰어난 오류 탐색 방법이 디버깅이며
### 1. 초기화 오류 2. 인덱스 범위 지정 오류 3. 잘못된 변수 사용 4 . 자료형 범위 오류 등의 문제를 낼 수 있고
### 로그를 찍느것보다 디버깅을 하는것이 시간을 아낄 수 있으며 더 효율적인 방법의 오류 탐색 방법이다.


## 자료구조

### 배열  
#### 인덱스를 통해 접근
#### 새로운 값 삽입 , 특정 인덱스 에 있는 값 삭제가 어려움 인덱스 이동이 필요
#### 선언후 크기 조절 불가 
#### 구조가 간단

### 리스트
#### 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
#### 인덱스가 없고 Head 포인트 부터 다시 접근하므로 접근속도가 느리다
#### 포인터로 연결되있기떄문에 데이터 삽입 삭제 하는 연산속도가 빠르다
#### 크기 변경에 유연하다
#### 포인터 저장할 공간이 필요하며 배열보다 구조가 복잡하다


