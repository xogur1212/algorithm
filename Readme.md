
# 2023.07.31
## 시간 복잡도와 알고리즘
### 시간 복잡도는 알고리즘의 선택기준 
### 보통 1억번의 연산 횟수를 1초의 시간으로 간주 ex) 2초의 제한 시간이라면 2억번의 연산 횟수를 말함

### 빅 오메가 -> 최선 일때
### 빅 세타 -> 보통 일때
### 빅 오 -> 최악의 경우

### 1부터 100까지의 랜덤한 수를
### 1부터 100까지 도는 for 문안에서 랜덤한 수를 만났을떄 break 한다면
### 1일때가 빅 오메가 일 것이며
### 100일때가 빅 오 이다

### 항상 빅오를 생각하고 코드를 짜는것이 중요

### 예를 들어 오름차순으로 수를 정렬하라는 문제에서
### 개수가 N (1<= N <= 1,000,000) 이라면

### 버블 정렬의 경우는 시간 복잡도가 n의 제곱
### 병합 정렬의 경우 n log n 이기 때문에 
### 병합 정렬이 시간 복잡도의 선택 기준에 따라 좀더 적합 하다고 할 수 있음

### 일반적으로 N vs 3N 앞에 상수는 무시함
### n의 제곱 같은 것과 비교가 되지않기 떄문에 상수는 무시

### 알맞은 알고리즘과 비효율적인 로직을 효율적으로 변경하는것이 핵심


# 2023.08.01

## 코드의 논리 오류 해결 디버깅

### 가장 뛰어난 오류 탐색 방법이 디버깅이며
### 1. 초기화 오류 2. 인덱스 범위 지정 오류 3. 잘못된 변수 사용 4 . 자료형 범위 오류 등의 문제를 낼 수 있고
### 로그를 찍느것보다 디버깅을 하는것이 시간을 아낄 수 있으며 더 효율적인 방법의 오류 탐색 방법이다.


## 자료구조

### 배열  
#### 인덱스를 통해 접근
#### 새로운 값 삽입 , 특정 인덱스 에 있는 값 삭제가 어려움 인덱스 이동이 필요
#### 선언후 크기 조절 불가 
#### 구조가 간단

### 리스트
#### 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
#### 인덱스가 없고 Head 포인트 부터 다시 접근하므로 접근속도가 느리다
#### 포인터로 연결되있기떄문에 데이터 삽입 삭제 하는 연산속도가 빠르다
#### 크기 변경에 유연하다
#### 포인터 저장할 공간이 필요하며 배열보다 구조가 복잡하다


# 2023.10.04

### 버블 정렬

#### 데이터의 인접 요소끼리 비교 swap 연산을 수행하여 정렬

#### 인전합 데이터의 크기를 비교해서 정렬 시간복잡도 O(n제곱) 
#### 다른 정렬 알고리즘 보다 속도가 느림
#### 인접한 데이터간의 swap 연산

1번째 루프

#### 42 32 24 60 15
#### 42 32swap

####32 42 24 60 15
####   42 24 swap

####32 24 42 60 15
####   42 60   no swap

#### 32 24 42 15 60 60만 정렬됨


#### 2번째 루프
#### 정렬되지 않는 내에서만 루프 실행

#### 32 24 42 15 60
#### 60 고정하고 32 24 비교 swap 



#####
= 10 + 9 + 8 + 7 +...+ 2 + 1 = 10 * (10 + 1) / 2 = 55

= N * ( N + 1 ) / 2

= N * N

= O( N * N )

 

### 순서
1. 비교 연산 필요 루프 설정
2. 인접한 데이터 비교
3. SWAP 조건 부합시 SWAP 연산 실행
4. 루프 범위가 끝날떄까지 2~3 반복
5. 정렬 영역 설정 다음 루프 실행할떄 이영역 제외
6. 비교 대상이 없을떄까찌 1~5실행

특정 영역에서 SWAP 한번도 발생하지 않을시 영역뒤 데이터 모두 정렬됨